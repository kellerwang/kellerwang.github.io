<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java编程最佳实践 | KylerのBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="转自喜马拉雅军校第一期班

说明
本文示例为了突出重点，没有写参数检验等代码，在实际项目中不要忽略。
本文重点列举Java语言和标准库上的通用优化建议，遵循这些建议可以在不改变系统框架和设计的情况下减少错误，提高效率。系统级优化需要对性能做全面的监测和分析，没有通用方法，本文涉及不多，建议阅读专业的Java性能优化相关资料。
代码首先要符合规范，保证可读性，在此基础上再优化。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java编程最佳实践">
<meta property="og:url" content="http://kyler.wang/2016/07/19/Java编程最佳实践/index.html">
<meta property="og:site_name" content="KylerのBlog">
<meta property="og:description" content="转自喜马拉雅军校第一期班

说明
本文示例为了突出重点，没有写参数检验等代码，在实际项目中不要忽略。
本文重点列举Java语言和标准库上的通用优化建议，遵循这些建议可以在不改变系统框架和设计的情况下减少错误，提高效率。系统级优化需要对性能做全面的监测和分析，没有通用方法，本文涉及不多，建议阅读专业的Java性能优化相关资料。
代码首先要符合规范，保证可读性，在此基础上再优化。">
<meta property="og:updated_time" content="2016-12-29T07:19:21.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java编程最佳实践">
<meta name="twitter:description" content="转自喜马拉雅军校第一期班

说明
本文示例为了突出重点，没有写参数检验等代码，在实际项目中不要忽略。
本文重点列举Java语言和标准库上的通用优化建议，遵循这些建议可以在不改变系统框架和设计的情况下减少错误，提高效率。系统级优化需要对性能做全面的监测和分析，没有通用方法，本文涉及不多，建议阅读专业的Java性能优化相关资料。
代码首先要符合规范，保证可读性，在此基础上再优化。">
  
    <link rel="alternate" href="/atom.xml" title="KylerのBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">KylerのBlog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">程序员 &amp; 旅行爱好者 &amp; 业余厨师</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://kyler.wang"></form>
      </div>
    </div>
  </div>
  <script>
    
    var d = new Date();
    var m = d.getMinutes();
    var num = Math.ceil((m + 1) / (60 / 6));
    document.getElementById("banner").style.backgroundImage = "url(/css/images/banner" + num + ".jpg)";
    
</script>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java编程最佳实践" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/19/Java编程最佳实践/" class="article-date">
  <time datetime="2016-07-19T11:47:58.000Z" itemprop="datePublished">2016-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/program/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java编程最佳实践
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
          <div id="toc" class="toc-article">
            <strong class="toc-title">文章目录</strong>
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#说明"><span class="toc-number">1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本类型"><span class="toc-number">2.</span> <span class="toc-text">基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多用基本类型，少用封装类型"><span class="toc-number">2.0.1.</span> <span class="toc-text">多用基本类型，少用封装类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#手动装箱时使用valueOf-type-，不用new"><span class="toc-number">2.0.2.</span> <span class="toc-text">手动装箱时使用valueOf([type])，不用new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用parseType-，不用valueOf-String"><span class="toc-number">2.0.3.</span> <span class="toc-text">使用parseType\，不用valueOf(String)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不用-比较浮点数"><span class="toc-number">2.0.4.</span> <span class="toc-text">不用==比较浮点数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用BigDecimal时注意小数位数"><span class="toc-number">2.0.5.</span> <span class="toc-text">使用BigDecimal时注意小数位数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">3.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#不要重复创建String对象"><span class="toc-number">3.0.1.</span> <span class="toc-text">不要重复创建String对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用StringBuilder连接字符串"><span class="toc-number">3.0.2.</span> <span class="toc-text">使用StringBuilder连接字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用StringBuilder时，如果可能，指定容量"><span class="toc-number">3.0.3.</span> <span class="toc-text">使用StringBuilder时，如果可能，指定容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不要用String代替其他类型"><span class="toc-number">3.0.4.</span> <span class="toc-text">不要用String代替其他类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用预编译的正则表达式"><span class="toc-number">3.0.5.</span> <span class="toc-text">使用预编译的正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#慎用String-intern"><span class="toc-number">3.0.6.</span> <span class="toc-text">慎用String.intern()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合"><span class="toc-number">4.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#返回值类型为集合时不要返回null，返回空集合"><span class="toc-number">4.0.1.</span> <span class="toc-text">返回值类型为集合时不要返回null，返回空集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用Collections创建小集合"><span class="toc-number">4.0.2.</span> <span class="toc-text">使用Collections创建小集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用ArrayList等在创建时可指定容量的集合时，如果可能，在创建时指定容量（capacity）"><span class="toc-number">4.0.3.</span> <span class="toc-text">使用ArrayList等在创建时可指定容量的集合时，如果可能，在创建时指定容量（capacity）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#默认使用ArrayList，有特殊需求时使用LinkedList"><span class="toc-number">4.0.4.</span> <span class="toc-text">默认使用ArrayList，有特殊需求时使用LinkedList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用EnumMap和EnumSet存储enum"><span class="toc-number">4.0.5.</span> <span class="toc-text">使用EnumMap和EnumSet存储enum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#去掉不必要的Map-containsKey和Set-contains调用"><span class="toc-number">4.0.6.</span> <span class="toc-text">去掉不必要的Map.containsKey和Set.contains调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Key插入Hash集合后确保hashCode的值不变"><span class="toc-number">4.0.7.</span> <span class="toc-text">Key插入Hash集合后确保hashCode的值不变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#默认使用Hash-Map-Set"><span class="toc-number">4.0.8.</span> <span class="toc-text">默认使用Hash[ Map,Set ]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不要在for-中修改集合"><span class="toc-number">4.0.9.</span> <span class="toc-text">不要在for( : )中修改集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#考虑使用BitSet"><span class="toc-number">4.0.10.</span> <span class="toc-text">考虑使用BitSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#谨慎使用数组的equals和hashCode"><span class="toc-number">4.0.11.</span> <span class="toc-text">谨慎使用数组的equals和hashCode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用Arrays操作数组"><span class="toc-number">4.0.12.</span> <span class="toc-text">使用Arrays操作数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用第三方库提升效率"><span class="toc-number">4.0.13.</span> <span class="toc-text">使用第三方库提升效率</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发"><span class="toc-number">5.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lazy-initialization"><span class="toc-number">5.0.1.</span> <span class="toc-text">Lazy initialization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优先使用线程池（Executor）"><span class="toc-number">5.0.2.</span> <span class="toc-text">优先使用线程池（Executor）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#及时关闭IO资源"><span class="toc-number">5.0.3.</span> <span class="toc-text">及时关闭IO资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不要一次把大文件的所有内容都读入内存"><span class="toc-number">5.0.4.</span> <span class="toc-text">不要一次把大文件的所有内容都读入内存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">6.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内存空间紧张的情况下，考虑long类型的毫秒数代替Date对象节省空间"><span class="toc-number">6.0.1.</span> <span class="toc-text">内存空间紧张的情况下，考虑long类型的毫秒数代替Date对象节省空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#避免并发使用java-text-SimpleDateFormat"><span class="toc-number">6.0.2.</span> <span class="toc-text">避免并发使用java.text.SimpleDateFormat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用不可变对象"><span class="toc-number">6.0.3.</span> <span class="toc-text">使用不可变对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不要使用异常代替正常执行流程"><span class="toc-number">6.0.4.</span> <span class="toc-text">不要使用异常代替正常执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多用final"><span class="toc-number">6.0.5.</span> <span class="toc-text">多用final</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不要在生产环境使用System-out-print-ln-写日志"><span class="toc-number">6.0.6.</span> <span class="toc-text">不要在生产环境使用System.out.print[ln]写日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#打日志时不要急于将对象转为String"><span class="toc-number">6.0.7.</span> <span class="toc-text">打日志时不要急于将对象转为String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择性使用"><span class="toc-number">6.0.8.</span> <span class="toc-text">选择性使用==</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优先使用static成员类"><span class="toc-number">6.0.9.</span> <span class="toc-text">优先使用static成员类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#及时释放对象引用"><span class="toc-number">6.0.10.</span> <span class="toc-text">及时释放对象引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用enum"><span class="toc-number">7.</span> <span class="toc-text">使用enum</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#慎用enum的ordinal"><span class="toc-number">7.0.1.</span> <span class="toc-text">慎用enum的ordinal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#少用反射"><span class="toc-number">7.0.2.</span> <span class="toc-text">少用反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#轮子优先级"><span class="toc-number">7.0.3.</span> <span class="toc-text">轮子优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#推荐的第三方库"><span class="toc-number">8.</span> <span class="toc-text">推荐的第三方库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#推荐阅读"><span class="toc-number">9.</span> <span class="toc-text">推荐阅读</span></a></li></ol>
          </div>
        
        <blockquote>
<p>转自喜马拉雅军校第一期班</p>
</blockquote>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol>
<li>本文示例为了突出重点，没有写参数检验等代码，在实际项目中不要忽略。</li>
<li>本文重点列举Java语言和标准库上的通用优化建议，遵循这些建议可以在不改变系统框架和设计的情况下减少错误，提高效率。系统级优化需要对性能做全面的监测和分析，没有通用方法，本文涉及不多，建议阅读专业的Java性能优化相关资料。</li>
<li>代码首先要符合规范，保证可读性，在此基础上再优化。</li>
</ol>
<a id="more"></a>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h4 id="多用基本类型，少用封装类型"><a href="#多用基本类型，少用封装类型" class="headerlink" title="多用基本类型，少用封装类型"></a>多用基本类型，少用封装类型</h4><p>只在需要使用对象时使用封装类型（如表示null，用于泛型）。</p>
<p>原因：</p>
<pre><code>1. 封装类型比基本类型占用更多的内存空间
2. 封装类型使用时需要判断是否为null
3. 拆装箱有性能损失
</code></pre><p>举例：</p>
<pre><code>// 当getInteger为null时randomNumber可能会抛异常
Integer getInteger(){...}
Integer randomNumber() {
    return random.nextBoolean() ? 1 : getInteger(); 
}

// 不断创建Integer，效率低
Integer sum = 0;
for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {
    sum += i;
}

// 封装类型比较时的异常行为 
Integer i1 = 1234;
Integer i2 = 1234;
// false 数值比较，i1.intValue()不小于i2.intValue()
System.out.println(i1 &lt; i2);
// false 引用一致性比较，i1和i2是不同对象
System.out.println(i1 == i2);
// false 数值比较，i1.intValue()不大于i2.intValue()
System.out.println(i1 &gt; i2);
</code></pre><h4 id="手动装箱时使用valueOf-type-，不用new"><a href="#手动装箱时使用valueOf-type-，不用new" class="headerlink" title="手动装箱时使用valueOf([type])，不用new"></a>手动装箱时使用valueOf([type])，不用new</h4><p>原因：</p>
<pre><code>Java标准库对整数类型的部分对象做了缓存，使用valueOf可以利用这些缓存减少内存使用量。
例如Integer默认对-128到127之间的对象做了缓存（可以通过jvm参数提高上限）。
</code></pre><p>举例：</p>
<pre><code>// bad
Integer integer2 = new Integer(123);

// good，但代码中没必要这样写，编译器会自动装箱
Integer integer1 = Integer.valueOf(123);
</code></pre><h4 id="使用parseType-，不用valueOf-String"><a href="#使用parseType-，不用valueOf-String" class="headerlink" title="使用parseType\，不用valueOf(String)"></a>使用parse<a href="String">Type\</a>，不用valueOf(String)</h4><p>原因：</p>
<pre><code>parse[Type](String)返回的是基本类型，valueOf(String)返回的是封装类型，所以需要基本类型时使用parse\[Type\]性能比较好；
在需要封装类型时，使用valueOf也不会带来性能提升，因为java编译器会做自动装箱，valueOf只是将自动装箱显式化。
</code></pre><p>举例：</p>
<pre><code>// bad
int i2 = Integer.valueOf(&quot;123&quot;);

// good
int i1 = Integer.parseInt(&quot;123&quot;);
</code></pre><h4 id="不用-比较浮点数"><a href="#不用-比较浮点数" class="headerlink" title="不用==比较浮点数"></a>不用==比较浮点数</h4><p>原因：</p>
<pre><code>float和double在计算机中不是精确存储的，直接用==比较会出现与预期结果不一样的情况。
</code></pre><p>举例：</p>
<pre><code>double d1 = 0.01D;
double d2 = 0.01F;
// false
System.out.println(d1 == d2);
</code></pre><p>实践：</p>
<pre><code>//使用BigDecimal精确表示浮点数 或 设置误差范围
boolean equals(double d1, double d2) {
    return Math.abs(d1 - d2) &lt; 0.0001;
}
</code></pre><h4 id="使用BigDecimal时注意小数位数"><a href="#使用BigDecimal时注意小数位数" class="headerlink" title="使用BigDecimal时注意小数位数"></a>使用BigDecimal时注意小数位数</h4><p>原因：</p>
<pre><code>小数位是BigDecimal的组成部分，小数位会影响BigDecimal比较结果。
</code></pre><p>举例：</p>
<pre><code>BigDecimal decimal1 = new BigDecimal(&quot;0.01&quot;);
BigDecimal decimal2 = new BigDecimal(&quot;0.010&quot;);
// false
System.out.println(decimal1.equals(decimal2));
// true
System.out.println(decimal1.equals(decimal2.setScale(2)));
</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h4 id="不要重复创建String对象"><a href="#不要重复创建String对象" class="headerlink" title="不要重复创建String对象"></a>不要重复创建String对象</h4><p>使用双引号（””）包围的字符串本身就是一个String对象，由于String是不可变的，所以可以直接使用，不要再用new String去创建新对象。</p>
<p>举例：</p>
<pre><code>// bad
String s = new String(&quot;abc&quot;);
// good
String s = &quot;abc&quot;;
</code></pre><h4 id="使用StringBuilder连接字符串"><a href="#使用StringBuilder连接字符串" class="headerlink" title="使用StringBuilder连接字符串"></a>使用StringBuilder连接字符串</h4><p>原因：</p>
<pre><code>使用+连接字符串时每使用一次+会重新构造一个String（简单情况下可能会优化为使用StringBuilder），
涉及多次数组复制，效率很低，StringBuilder使用动态增长的数组存储字符，效率高。
</code></pre><p>举例：</p>
<pre><code>// bad
String join(List&lt;String&gt; list) {
    String joined = &quot;&quot;;
    for (String s : list) {
        joined += s;
    }
    return joined;
}

// good
String join(List&lt;String&gt; list) {
    StringBuilder joinedBuilder = new StringBuilder();
    for (String s : list) {
        joinedBuilder.append(s);
    }
    return joinedBuilder.toString();
}
</code></pre><h4 id="使用StringBuilder时，如果可能，指定容量"><a href="#使用StringBuilder时，如果可能，指定容量" class="headerlink" title="使用StringBuilder时，如果可能，指定容量"></a>使用StringBuilder时，如果可能，指定容量</h4><p>原因：</p>
<pre><code>如果不指定容量，StringBuilder容量动态增加，涉及到创建临时数组和数组复制，影响性能。
</code></pre><p>举例：</p>
<pre><code>String repeat(String string, int count) {
    StringBuilder buffer = new StringBuilder(string.length() * count);
    for(int i = 0; i &lt; count; i++) {
        buffer.append(string);
    }
    return buffer.toString();
}
</code></pre><h4 id="不要用String代替其他类型"><a href="#不要用String代替其他类型" class="headerlink" title="不要用String代替其他类型"></a>不要用String代替其他类型</h4><p>从IO或者远程调用得到String后，如果可能，应先转为合适的类型再做后续处理；在程序内部，除了日志、前后端交互等必须使用String的场景外，应避免将其他类型对象转为String后再做处理。</p>
<p>原因：</p>
<pre><code>1. String更占空间
2. String丢失了数据的原始类型，难做类型校验
3. 对String的处理通常比原数据类型的处理效率更低
</code></pre><p>举例：</p>
<pre><code>// bad，效率低，费空间
class SimpleCache1 {
    private Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();

    public void put(long id1, long id2, String value) {
        map.put(id1 + &quot;&amp;&quot; + id2, value);
    }

    public String get(long id1, long id2) {
        return map.get(id1 + &quot;&amp;&quot; + id2);
    }
}

// good，效率高，省空间
class SimpleCache2 {
    static class Ids {
        private long id1;
        private long id2;

        public Ids(long id1, long id2) {
            this.id1 = id1;
            this.id2 = id2;
        }

        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + (int) (id1 ^ (id1 &gt;&gt;&gt; 32));
            result = prime * result + (int) (id2 ^ (id2 &gt;&gt;&gt; 32));
            return result;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            if (!(obj instanceof Ids)) {
                return false;
            }
            Ids other = (Ids) obj;
            if (id1 != other.id1) {
                return false;
            }
            if (id2 != other.id2) {
                return false;
            }
            return true;
        }
    }

    private Map&lt;Ids, String&gt; map = new HashMap&lt;Ids, String&gt;();

    public void put(long id1, long id2, String value) {
        map.put(new Ids(id1, id2), value);
    }

    public String get(long id1, long id2) {
        return map.get(new Ids(id1, id2));
    }
}
</code></pre><h4 id="使用预编译的正则表达式"><a href="#使用预编译的正则表达式" class="headerlink" title="使用预编译的正则表达式"></a>使用预编译的正则表达式</h4><p>原因：</p>
<pre><code>复杂正则表达式的编译比较耗时
</code></pre><p>举例：</p>
<pre><code>// bad，每次调用string.replaceAll都会创建Pattern
List&lt;String&gt; replaceAll1(List&lt;String&gt; strings, String regex, String  replacement) {
    List&lt;String&gt; replaced = new ArrayList&lt;String&gt;(strings.size());
    for (String string : strings) {
        replaced.add(string.replaceAll(regex, replacement));
    }
    return replaced;
}

// good
List&lt;String&gt; replaceAll2(List&lt;String&gt; strings, String regex, String replacement) {
    List&lt;String&gt; replaced = new ArrayList&lt;String&gt;(strings.size());
    Pattern pattern = Pattern.compile(regex);
    for (String string : strings) {
        Matcher matcher = pattern.matcher(string);
        replaced.add(matcher.replaceAll(replacement));
    }
    return replaced;
}
</code></pre><h4 id="慎用String-intern"><a href="#慎用String-intern" class="headerlink" title="慎用String.intern()"></a>慎用String.intern()</h4><p>String.intern()对两个a.equals(b)的String返回相同的引用，看起来能节省空间，但要慎用，尤其是在java6中。</p>
<p>原因：</p>
<pre><code>1. java6中intern字符串池是创建在PermGen上的，PermGen通常设置的比较小，且运行时不可扩展，
   String.intern()容易引起PermGen内存溢出
2. java7和8中intern字符串池是创建在heap上的，但大小是固定的，可以通过jvm参数-XX:StringTableSize修改，
   修改时需要注意选择合适的大小，否则性能会严重退化，建议设置成接近字符串数两倍的一个素数
</code></pre><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h4 id="返回值类型为集合时不要返回null，返回空集合"><a href="#返回值类型为集合时不要返回null，返回空集合" class="headerlink" title="返回值类型为集合时不要返回null，返回空集合"></a>返回值类型为集合时不要返回null，返回空集合</h4><p>原因：</p>
<pre><code>空集合和非空集合使用方法一致，null需要做特判，增加代码复杂度。
</code></pre><h4 id="使用Collections创建小集合"><a href="#使用Collections创建小集合" class="headerlink" title="使用Collections创建小集合"></a>使用Collections创建小集合</h4><p>原因：</p>
<pre><code>Collections中提供了创建不可变空集合（emptyXxx）和单元素集合（singletonXxx）的工厂方法，使用这些方法创建的小集合省空间，效率高。
</code></pre><p>举例：</p>
<pre><code>List&lt;String&gt; splitToList(String input, String separator) {
    if (input == null) {
        return Collections.emptyList();
    }
    ...
}
</code></pre><h4 id="使用ArrayList等在创建时可指定容量的集合时，如果可能，在创建时指定容量（capacity）"><a href="#使用ArrayList等在创建时可指定容量的集合时，如果可能，在创建时指定容量（capacity）" class="headerlink" title="使用ArrayList等在创建时可指定容量的集合时，如果可能，在创建时指定容量（capacity）"></a>使用ArrayList等在创建时可指定容量的集合时，如果可能，在创建时指定容量（capacity）</h4><p>原因：</p>
<pre><code>这类集合通常使用数组保存数据，如果数组填满，会创建一个新数组，将数据复制到新数组中，然后利用新数组存储数据，数组增长过程既费时又费空间。
</code></pre><p>举例：</p>
<pre><code>List&lt;String&gt; joinKeyValue(Map&lt;String, String&gt; map) {
    List&lt;String&gt; result = new ArrayList(map.size());
    ...
}
</code></pre><h4 id="默认使用ArrayList，有特殊需求时使用LinkedList"><a href="#默认使用ArrayList，有特殊需求时使用LinkedList" class="headerlink" title="默认使用ArrayList，有特殊需求时使用LinkedList"></a>默认使用ArrayList，有特殊需求时使用LinkedList</h4><p>当只使用List接口定义的方法时，使用ArrayList，在有以下需求时使用LinkedList：</p>
<pre><code>1. 使用Deque接口定义的方法
2. 在List中间频繁执行add或remove操作，这时应使用Iterator或ListIterator顺序访问，不要使用List.add(int,T)和List.remove(int)
</code></pre><p>原因：</p>
<pre><code>1. LinkedList比ArrayList更占空间，LinkedList使用Node存储数据，Node中有previous、next引用，都需要占用额外空间
2. ArrayList随机访问速度比LinkedList快
3. LinkedList顺序访问过程中进行add或remove时只需改变部分引用，效率较高
</code></pre><h4 id="使用EnumMap和EnumSet存储enum"><a href="#使用EnumMap和EnumSet存储enum" class="headerlink" title="使用EnumMap和EnumSet存储enum"></a>使用EnumMap和EnumSet存储enum</h4><p>原因：</p>
<pre><code>1. EnumMap使用简单的数组存储value，省空间，效率高
2. EnumSet使用位域存储数据，省空间，效率高
</code></pre><h4 id="去掉不必要的Map-containsKey和Set-contains调用"><a href="#去掉不必要的Map-containsKey和Set-contains调用" class="headerlink" title="去掉不必要的Map.containsKey和Set.contains调用"></a>去掉不必要的Map.containsKey和Set.contains调用</h4><p>有些组合操作可以避免使用Map.containsKey和Set.contains，提高效率<br>举例：</p>
<pre><code>Map&lt;K, V&gt; map = new HashMap&lt;K, V&gt;();
// bad，不必要的containsKey
if (map.containsKey(key)) {
    System.out.println(map.get(key).size());
}
// good
V value = map.get(key);
if (value != null) {
    System.out.println(value.size());
}

Map&lt;K, List&lt;V&gt;&gt; listMap = new HashMap&lt;K, List&lt;V&gt;&gt;();
// bad，不必要的containsKey
if (!listMap.containsKey(k)) {
    listMap.put(k, new ArrayList&lt;V&gt;());
}
listMap.get(k).add(v);
// good
List&lt;V&gt; list = listMap.get(k);
if (list == null) {
    list = new ArrayList();
    listMap.put(k, list);
}
list.add(v);

Set&lt;V&gt; set = new HashSet&lt;V&gt;();
// bad，不必要的contains
if (!set.contains(value)) {
    set.add(value);
    // do something
}
// good
if (set.add(value)){
    // do something
}
</code></pre><h4 id="Key插入Hash集合后确保hashCode的值不变"><a href="#Key插入Hash集合后确保hashCode的值不变" class="headerlink" title="Key插入Hash集合后确保hashCode的值不变"></a>Key插入Hash集合后确保hashCode的值不变</h4><p>原因：</p>
<pre><code>改变hashCode值后可能会找不到原来插入的值。
</code></pre><h4 id="默认使用Hash-Map-Set"><a href="#默认使用Hash-Map-Set" class="headerlink" title="默认使用Hash[ Map,Set ]"></a>默认使用Hash[ Map,Set ]</h4><p>在没有其他需求时默认使用Hash[ Map,Set ]，需要有序时使用TreeMap，需要按插入顺序有序时使用LinkedHashMap，需要并发时使用ConcurrentHashMap。<br>原因：</p>
<pre><code>基于Hash的实现在大部分情况下性能都比较好。
</code></pre><h4 id="不要在for-中修改集合"><a href="#不要在for-中修改集合" class="headerlink" title="不要在for( : )中修改集合"></a>不要在for( : )中修改集合</h4><p>原因：</p>
<pre><code>会对集合创建多个Iterator，导致抛ConcurrentModificationException
</code></pre><p>举例：</p>
<pre><code>// bad
for (int i : list) {
    if (i % 10 == 0) {
        list.remove(i);
    }
}
// good
for (Iterator&lt;Integer&gt; iterator = list.iterator(); iterator.hasNext();) {
    int i = iterator.next();
    if (i % 10 == 0) {
        iterator.remove();
    }
}
</code></pre><h4 id="考虑使用BitSet"><a href="#考虑使用BitSet" class="headerlink" title="考虑使用BitSet"></a>考虑使用BitSet</h4><p>当需要使用Set&lt;[Integer,Short,Byte,Char]&gt;并且数据集中在较小范围内时，可以使用BitSet代替。<br>原因：</p>
<pre><code>1. BitSet使用位域实现存储，省空间
2. BitSet使用位操作实现功能，效率高
</code></pre><p>举例：</p>
<pre><code>// 简单的分段BitSet，存储分段密集的数字时节省空间
class SimpleIntSet {
    private static final int VALUE_BITS = 10;
    private static final int VALUE_MASK = (1 &lt;&lt; VALUE_BITS) - 1;
    private Map&lt;Integer, BitSet&gt; bitSetMap = new HashMap&lt;Integer, BitSet&gt;();

    public void add(int value) {
        int key = getKey(value);
        BitSet set = bitSetMap.get(key);
        if (set == null) {
            set = new BitSet(VALUE_MASK + 1);
            bitSetMap.put(key, set);
        }
        set.set(getBitIndex(value));
    }

    public void remove(int value) {
        BitSet set = bitSetMap.get(getKey(value));
        if (set != null) {
            set.clear(getBitIndex(value));
        }
    }

    public boolean contains(int value) {
        BitSet set = bitSetMap.get(getKey(value));
        return set == null || set.get(getBitIndex(value));
    }

    private int getBitIndex(int value) {
        return value &amp; VALUE_MASK;
    }

    private int getKey(int value) {
        return value &gt;&gt; VALUE_BITS;
    }

}
</code></pre><h4 id="谨慎使用数组的equals和hashCode"><a href="#谨慎使用数组的equals和hashCode" class="headerlink" title="谨慎使用数组的equals和hashCode"></a>谨慎使用数组的equals和hashCode</h4><p>数组的equals和hashCode是Object中的默认实现，大部分情况下都不满足需求。需要使用equals和hashCode时，可以使用Buffer封装（基本类型数组），利用Arrays中提供的静态方法，使用Arrays.asList封装为List。</p>
<h4 id="使用Arrays操作数组"><a href="#使用Arrays操作数组" class="headerlink" title="使用Arrays操作数组"></a>使用Arrays操作数组</h4><p>Java数组本身提供的方法很少，Arrays中提供了toString、equals、hashCode、copy操作数组的静态方法，可以利用这些方法方便地使用数组。<br>举例：</p>
<pre><code>// copyOfRange
int[] shiftLeft(int[] original, int shiftLength) {
    int from = Math.min(original.length, shiftLength);
    int to = from + original.length;
    return Arrays.copyOfRange(original, from, to);
}
// deepToString
int[][][] threeDArray = new int[][][]{{{1,2,3},{4}},{{5},{6,7}}};
System.out.println(Arrays.deepToString(threeDArray));
</code></pre><h4 id="使用第三方库提升效率"><a href="#使用第三方库提升效率" class="headerlink" title="使用第三方库提升效率"></a>使用第三方库提升效率</h4><p>在Java标准库中提供的集合在空间和时间复杂度上不能满足需求时，可以尝试trove等第三方库。<br>原因：</p>
<pre><code>1. Java标准集合都是使用范型实现的，当存储数据为基本类型时需要封装，有额外的空间和性能消耗
2. Java标准库中常用的Set（HashSet，TreeSet，LinkedHashSet）是封装Map实现的，Map中value所占的空间被浪费了
</code></pre><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h4 id="Lazy-initialization"><a href="#Lazy-initialization" class="headerlink" title="Lazy initialization"></a>Lazy initialization</h4><p>Java中常用的Lazy initialization方式如下：</p>
<pre><code>//使用静态辅助类
class SomeClass {
    private static class InstanceHolder {
        static SomeClass instance = new SomeClass();
    }

    public static SomeClass getInstance() {
        return InstanceHolder.instance;
    }
}

//使用volatile的double check
class SomeFactory {
    // 注意必须有volatile
    private volatile SomeClass someObject;

    public SomeClass getSomeObject() {
        if (someObject == null) {
            synchronized (this) {
                if (someObject == null) {
                    someObject = new SomeClass();
                }
            }
        }
        return someObject;
    }
}

// 使用final的double check
class FinalWrapper&lt;T&gt; {
    // 注意必须有final
    private final T value;

    FinalWrapper(T value) {
        this.value = value;
    }

    T getValue() {
        return value;
    }
}

class SomeFactory {
    private FinalWrapper&lt;SomeClass&gt; finalWrapper;

    public SomeClass getSomeObject() {
        if (finalWrapper == null) {
            synchronized (this) {
                if (finalWrapper == null) {
                    finalWrapper = new FinalWrapper&lt;SomeClass&gt;(new SomeClass());
                }
            }
        }
        return finalWrapper.getValue();
    }
}
</code></pre><p>####优先使用ConcurrentMap<br>需要并发Map时优先使用ConcurrentMap，包括无序的ConcurrentHashMap和有序的ConcurrentSkipListMap。</p>
<p>原因：</p>
<pre><code>1. ConcurrentMap内部使用锁分段等并发优化技术实现，在高并发情况下比简单的使用锁封装map以及使用Collections.synchronizedMap效率高
2. ConcurrentMap有compare and set方式的putIfAbsent、remove、replace原子操作，可以简化并发程序实现方式
</code></pre><p>举例：</p>
<pre><code>// “如果map中有key，返回value；如果没有，新建一个value，放入map中，然后返回”功能的安全高效实现
Value createIfAbsent(ConcurrentMap&lt;Key, Value&gt; map, Key key) {
    Value value = map.get(key);
    if (value != null) {
        return value;
    }
    value = new Value();
    Value oldValue = map.putIfAbsent(key, value);
    if (oldValue != null) {
        return oldValue;
    } else {
        return value;
    }
}
</code></pre><p>####考虑使用CopyOnWrite集合<br>当集合的读远多于写时可以考虑使用CopyOnWrite集合，java标准库中提供了CopyOnWriteArrayList和CopyOnWriteArraySet。<br>原因：</p>
<pre><code>CopyOnWrite集合的读操作未加锁，效率高
</code></pre><h4 id="优先使用线程池（Executor）"><a href="#优先使用线程池（Executor）" class="headerlink" title="优先使用线程池（Executor）"></a>优先使用线程池（Executor）</h4><p>在创建线程时优先考虑使用线程池，而不是直接创建Thread。<br>原因：</p>
<pre><code>1. 使用线程池便于控制线程数
2. 使用线程池便于对任务进行统一管理
3. 使用线程池可以复用线程，减少创建、销毁线程的开支
4. 利用Future可以方便地进行异步调用和超时控制
</code></pre><p>注意在使用线程池时ThreadLocal等属于线程的资源也会被复用。</p>
<p>####优先使用Atomic[Type]<br>java.util.concurrent.atomic提供了部分基本类型及其数组的Atomic封装，在并发环境下应当优先使用。<br>原因：</p>
<pre><code>1. Atomic使用volatile语义及底层compareAndSet实现，高并发情况下效率比直接用锁高
2. 提供了原子的[update]AndGet以及getAnd[Update]方法，效率高，使用方便
</code></pre><p>####选择合适的锁<br>默认使用synchronized，需要更多控制时使用ReentrantLock，读多于写时考虑使用ReentrantReadWriteLock。<br>原因：</p>
<pre><code>1. synchronized用法最简单，不容易出错
2. ReentrantLock比synchronized功能更多（处理中断，tryLock，多个condition...）
3. ReentrantReadWriteLock读写锁分离，可并发读
</code></pre><p>##IO</p>
<p>####指定编码<br>涉及流（stream、byte）和字符（char、String）转换的地方一定要指定编码。<br>原因：</p>
<pre><code>如果不指定编码，程序会使用默认编码，默认编码在开发机、测试机、线上环境可能不一样，引发难以测试和复现的问题
</code></pre><p>举例：</p>
<pre><code>byte[] bytes = ...
// bad
String s = new String(bytes);
// good
String s = new String(bytes, Charset.forName(&quot;utf-8&quot;));

// bad，不要用FileReader，因为无法指定编码
BufferedReader reader = new BufferedReader(new FileReader(&quot;/home/work/somefile&quot;));
// good
BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;/home/work/somefile&quot;), Charset.forName(&quot;utf-8&quot;)));
</code></pre><p>####合理使用ByteArrayOutputStream<br>ByteArrayOutputStream有以下缺点，使用时需要注意：</p>
<pre><code>1. write方法是synchronized方法，影响性能
2. toByteArray会复制一个新的byte数组，影响性能，占用空间
</code></pre><p>在使用时可以采取如下方法：</p>
<pre><code>1. 如果byte数组长度已知，不要使用ByteArrayOutputStream，使用ByteBuffer
2. 如果byte数组需要输出到一个stream，使用ByteArrayOutputStream.writeTo(OutputStream stream)
3. 如果byte数组需要转成字符串，使用ByteArrayOutputStream.toString(String charsetName)
</code></pre><h4 id="及时关闭IO资源"><a href="#及时关闭IO资源" class="headerlink" title="及时关闭IO资源"></a>及时关闭IO资源</h4><p>使用完IO资源后应该尽快关闭，否则会引起资源泄漏，资源关闭需要在finally里面进行，有些资源关闭时会抛IOException，在不关注这个异常时推荐使用org.apache.commons.io.IOUtils.closeQuietly方法。</p>
<h4 id="不要一次把大文件的所有内容都读入内存"><a href="#不要一次把大文件的所有内容都读入内存" class="headerlink" title="不要一次把大文件的所有内容都读入内存"></a>不要一次把大文件的所有内容都读入内存</h4><p>这样容易引起OOM，应当分块读入文件，边读边处理。</p>
<pre><code>File file = new File(&quot;somefile&quot;);
try (BufferedInputStream stream = new BufferedInputStream(new FileInputStream(file))) {
    // bad
    byte[] bytes = new byte[(int) file.length()];
    stream.read(bytes);
    // Do something
}

try (BufferedInputStream stream = new BufferedInputStream(new FileInputStream(file))) {
    // good
    byte[] bytes = new byte[10240];
    int readCount = 0;
    while ((readCount = stream.read(bytes)) != -1) {
        // Do something
    }
}
</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="内存空间紧张的情况下，考虑long类型的毫秒数代替Date对象节省空间"><a href="#内存空间紧张的情况下，考虑long类型的毫秒数代替Date对象节省空间" class="headerlink" title="内存空间紧张的情况下，考虑long类型的毫秒数代替Date对象节省空间"></a>内存空间紧张的情况下，考虑long类型的毫秒数代替Date对象节省空间</h4><p>原因：</p>
<pre><code>Date只是对毫秒数的简单封装，没有必要创建Date对象再获得毫秒数。
</code></pre><h4 id="避免并发使用java-text-SimpleDateFormat"><a href="#避免并发使用java-text-SimpleDateFormat" class="headerlink" title="避免并发使用java.text.SimpleDateFormat"></a>避免并发使用java.text.SimpleDateFormat</h4><p>原因：</p>
<pre><code>SimpleDateFormat不是线程安全的，建议使用apache commons-lang的FastDateFormat等第三方库。
</code></pre><h4 id="使用不可变对象"><a href="#使用不可变对象" class="headerlink" title="使用不可变对象"></a>使用不可变对象</h4><p>不可变对象有以下优点：</p>
<pre><code>1. 线程安全
2. 可以缓存
3. 可以缓存hashCode等计算结果
</code></pre><h4 id="不要使用异常代替正常执行流程"><a href="#不要使用异常代替正常执行流程" class="headerlink" title="不要使用异常代替正常执行流程"></a>不要使用异常代替正常执行流程</h4><p>原因：</p>
<pre><code>Java中创建异常需要填充stackTrace，代价非常高，异常应当只用于表示在正常流程之外且很少发生的情况
</code></pre><h4 id="多用final"><a href="#多用final" class="headerlink" title="多用final"></a>多用final</h4><p>原因：</p>
<pre><code>1. jvm更容易对final域及final方法进行优化，提高运行时效率
2. 编译器可以利用final及时提示代码错误
3. 正确初始化的final域在并发环境下可以保证安全发布
</code></pre><h4 id="不要在生产环境使用System-out-print-ln-写日志"><a href="#不要在生产环境使用System-out-print-ln-写日志" class="headerlink" title="不要在生产环境使用System.out.print[ln]写日志"></a>不要在生产环境使用System.out.print[ln]写日志</h4><p>原因：</p>
<pre><code>1. System.out.print[ln]默认输出到控制台，难管理
2. System.out.print[ln]不支持日志分级
3. System.out.print[ln]默认遇到&apos;\n&apos;就会flush，效率较低
</code></pre><h4 id="打日志时不要急于将对象转为String"><a href="#打日志时不要急于将对象转为String" class="headerlink" title="打日志时不要急于将对象转为String"></a>打日志时不要急于将对象转为String</h4><p>原因：</p>
<pre><code>日志是有级别的，打印级别低于系统设置级别的日志不会被输出，这些日志提前转为String浪费资源
</code></pre><p>举例：</p>
<pre><code>// slf4j bad
logger.debug(someLogObject.toString());
logger.debug(&quot;Log object1: &quot; + someLogObject1 + &quot;, object2: &quot; + someLogObject2);
// slf4j good
logger.debug(&quot;{}&quot;, someLogObject);
logger.debug(&quot;Log object1: {}, object2: {}&quot;, someLogObject1, someLogObject2);

// log4j bad
logger.debug(someLogObject.toString());
logger.debug(&quot;Log object1: &quot; + someLogObject1 + &quot;, object2: &quot; + someLogObject2);
// log4j good
logger.debug(someLogObject);
if (logger.isDebugEnabled()) {
    logger.debug(new StringBuilder(&quot;Log object1: &quot;)
            .append(someLogObject1)
            .append(&quot;, object2: &quot;)
            .append(someLogObject2));
}
</code></pre><p>从上面的代码可以看出，实现相同的功能log4j比slf4j需要多一次判断，不够简洁，所以不建议直接使用log4j，使用slf4j封装或者使用其他有占位符的日志框架，比如logback。</p>
<h4 id="选择性使用"><a href="#选择性使用" class="headerlink" title="选择性使用=="></a>选择性使用==</h4><p>对基本类型使用==时，比较的是数据是否完全一致，对引用类型使用==时，比较的是引用地址是否一致，以下情况可以安全地使用==比较是否相等：</p>
<pre><code>1. 整数基本类型
2. 枚举类型
</code></pre><p>其他情况下，==比较的是两者是否为同一对象。java.util.IdentityHashMap是仅使用==比较key是否相等的HashMap，在有些场景下可以用来提高效率。</p>
<h4 id="优先使用static成员类"><a href="#优先使用static成员类" class="headerlink" title="优先使用static成员类"></a>优先使用static成员类</h4><p>static成员类与非static成员类的区别是非static成员类包含一个外部类的指针，可以访问外部类的非静态资源。当需要使用成员类时，默认使用static成员类，除非需要访问外部类的非静态资源。<br>原因：</p>
<pre><code>1. 非static内部类占用额外空间存储外部类的引用
2. 非static内部类影响外部类对象的内存回收，可能会引起内存泄漏
</code></pre><h4 id="及时释放对象引用"><a href="#及时释放对象引用" class="headerlink" title="及时释放对象引用"></a>及时释放对象引用</h4><p>及时释放对象引用可以让jvm及时释放内存空间，忘记释放对象引用可能会引起内存泄漏。<br>举例：</p>
<pre><code>class SimpleStack {
    private Object[] array = new Object[10];
    private int index = 0;

    public void push(Object value) {
        if (index == array.length) {
            array = Arrays.copyOf(array, array.length * 2);
        }
        array[index++] = value;
    }

    public Object pop() {
        // 这里内存泄漏，需要在返回前将array[index]置为null
        return array[--index];
    }
}
</code></pre><h2 id="使用enum"><a href="#使用enum" class="headerlink" title="使用enum"></a>使用enum</h2><p>使用enum替代常量。<br>原因：</p>
<pre><code>1. enum是类型安全的
2. enum可以定义方法，功能强大
3. enum可以使用==进行比较，使用EnumHashMap等工具，效率高
</code></pre><p>举例：</p>
<pre><code>public class Constants{
    public static final String OS_ANDROID = &quot;Android&quot;;
    public static final String OS_IOS = &quot;iOS&quot;;
}

public enum Os {
    ANDROID(&quot;Android&quot;),
    IOS(&quot;iOS&quot;);

    private String osName;

    private Os(String osName) {
        this.osName = osName;
    }

    public String getOsName() {
        return this.osName;
    }
}
</code></pre><h4 id="慎用enum的ordinal"><a href="#慎用enum的ordinal" class="headerlink" title="慎用enum的ordinal"></a>慎用enum的ordinal</h4><p>在程序中要慎用enum的ordinal，尤其在需要持久化的场景，需要使用数字表达时可以用自定义值代替。<br>原因：</p>
<pre><code>1. 调整常量顺序或者删除常量时ordinal会发生变化
2. ordinal只与常量顺序有关，无法定义有意义的值
</code></pre><h4 id="少用反射"><a href="#少用反射" class="headerlink" title="少用反射"></a>少用反射</h4><p>原因：</p>
<pre><code>1. 反射无法进行编译检查，降低了提早发现问题的可能性，无法方便地发现调用点，增加重构难度
2. 损失性能，反射比正常方法调用要慢
3. 反射代码不如直接调用简洁
</code></pre><h4 id="轮子优先级"><a href="#轮子优先级" class="headerlink" title="轮子优先级"></a>轮子优先级</h4><pre><code>1. 标准库
2. 第三方库
3. 自己造
</code></pre><h2 id="推荐的第三方库"><a href="#推荐的第三方库" class="headerlink" title="推荐的第三方库"></a>推荐的第三方库</h2><pre><code>1. apache-commons，java.lang的补充，提供了很多辅助工具
2. apache-collections，java集合的补充，提供了很多集合操作工具和新的集合
3. guava，提供了很多集合、并发、缓存等方面的工具
</code></pre><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><pre><code>1. Effective Java (Second Edition)
2. Java Concurrency in Practice
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://kyler.wang/2016/07/19/Java编程最佳实践/" data-id="cixa1ygov0003j6pe2zzkcgoj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/08/02/转载-Python-脚本帮你找出微信上删除你好友的人/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          转载-Python 脚本帮你找出微信上删除你好友的人
        
      </div>
    </a>
  
  
    <a href="/2016/07/19/OOAD5大原则理解/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">OOAD5大原则理解</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <h1 class="title">Comments</h1>
  <div id="disqus_thread">
    <!-- UY BEGIN -->
    <div id="uyan_frame"></div>
    <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2122804"></script>
    <!-- UY END -->
  </div>
</section>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/program/">技术</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/12/28/sublime-markdown实践/">sublime+markdown实践</a>
          </li>
        
          <li>
            <a href="/2016/08/02/转载-Python-脚本帮你找出微信上删除你好友的人/">转载-Python 脚本帮你找出微信上删除你好友的人</a>
          </li>
        
          <li>
            <a href="/2016/07/19/Java编程最佳实践/">Java编程最佳实践</a>
          </li>
        
          <li>
            <a href="/2016/07/19/OOAD5大原则理解/">OOAD5大原则理解</a>
          </li>
        
          <li>
            <a href="/2016/07/15/使用Hexo构建Blog/">使用Hexo构建Blog</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    <div class="widget-wrap">
  <h3 class="widget-title">Weibo</h3>
  <div class="widget" style="padding: 0px">
	<iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=1919577123&verifier=7815e688&dpc=1"></iframe>
  </div>
</div>
  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Kyler Wang
      <br>
      <!-- 不蒜统计 -->
  	  <span style="display: inline;" id="busuanzi_container_site_uv">本站总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑" style="color:white"></span> 次</span>
  	  <span style="display: inline;" id="busuanzi_container_site_pv">本站总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑" style="color:white"></span> 次</span>
      <br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>